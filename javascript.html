<!DOCTYPE html>
<htnl lang="en">
    <head>
        <title>JavaScript
        </title>
        <link rel="stylesheet" href="javascript.css">
        <script src="javascript.js"></script>
    </head>
    <body>
        <header>
            <h1>JavaScript</h1>
        </header>
            <main>
            <h2>JavaScript Review</h2>
           <button onclick="display('Hello World!')">Click Me</button>
           <br><br>
           <code>
            function display(message) {
            document.write(message);
            }
           </code>
           <h2>Functions</h2>

           <pre>
                Activator function
                ------------------
                <code>
                    function greeting () {
                        display("Hello World!");
                    }
                </code>

                A function that doesn't have parameters. It still runs without error if you set a parameter. 
                Its only purpose is to call a function with parameters.<br>
                <button onclick="greeting()">Activate Me</button>
            </pre>
            <pre>
                Activator Experiment
                --------------------
                Send a value to an activator function.
                Add a parameter to the activator function to access the value.
                            
                <code>
                function activatorTest() {
                display("Experimenting with an activator function.");
                }

                function activatorTest(myParameter){
                display(myParameter);
                }
                </code>

                <button onclick="activatorTest('Hello World!')">Activator Test</button><br>
                <button onclick="activatorTest(event)">Make a Promise</button>

                What do you observe about sending values to activator functions?
                A value can be sent to functions without parameters.
                Add a parameter to the function to access the value.
                View the parameter by looking at the Scope in the debugger.     
           </pre>
        
           <pre>
                Callback function
                ------------------
                <code>
                    function myFunction(callbackFunction){
                        callbackFunction();
                    }
                    function activator(){
                        myFunction(greeting);
                    }
                    activator();
                </code>
                A function that is passed as a parameter.
                A function can be passed to another function.
                The function can run that function.<br>
                <button onclick="activator()">Activate Me</button>
            </pre>

            <pre>
                setTimeout function
                -------------------
                <code>
                    function delayedGreeting() {
                        setTimeout(greeting, 5000);
                    }
                </code>
                A function that calls a function after a specified time.
                It accepts a function and a delay time in milliseconds.<br>
                <button onclick="activator()">Delayed Greeting</button>
            </pre>

            <pre>
                Asynchronous function
                ----------------------
                <code>
                    function asynchronous () {
                        setTimeout(greeting, 5000);
                        display("Waiting for the greeting...");
                    }
                </code>
                Able to run other code while waiting for some code to respond, like multitasking.
                Other code runs immediately after <code>setTimeout</code>.
                The <code>greeting</code> function runs after other code.<br>
                <button onclick="asynchronous()">Delayed Greeting</button>
            </pre>

            <pre>
                Server simulation
                -----------------
                A server takes time to respond. Use asynchronous code to simulate it. 
                <code>
                    function submitForm(event) {
                        const inputs = event.target;
                        const emailInput = inputs[0];
                        const email = emailInput.value;
                        display("Submitting for " + email + " ...");
                        setTimeout(serverResponse, 5000);
                    }
                    
                    function serverResponse() {
                       display("Form was successfully processed.");
                    }                    
                </code>
                <form onsubmit="submitForm(event)">
                    <label for="email">Email:</label><br>
                    <input type="email" id="email" name="email" required><br>
                    <input type="submit">
                </form>
            </pre>
            <pre>
                JSON Stringify                
                --------------
                JavaScript Object Notation
                Stringify generates a string from an object.
                <code>
                    function displayObject() {
                        const myCar = { color: "red", year: 2024 };
                        const result = JSON.stringify(myCar);
                        display(result);
                    }                    
                </code>
                Need to store results to display them.
                This is the syntax we use to represent objects. Servers communicate with stringified objects.
                {} represent an object.
                , separates properties.
                "" sets properties.
                : sets values.

                <button onclick="displayObject()">Display Object</button><br>
                Servers communicate with stringified objects.
                    Open a chrome browser tab.
                    Go to https://opentdb.com/api.php?amount=1
                    View the stringified object.

                    MS Edge auto formats strigified objects.
            </pre>

            <pre>
                JavaScript class
                -----------------
                <code>
                    class MyCar {
                        color = "red";
                        year = 2024;
                    }
                </code>
                A JavaScript class is like a template. It predefines an object without creating it. 
                Usually defined towards the top of a file. 
                Directly displaying a class shows its code. 

                Syntax:
                1. Keyword <code>class</code>.
                2. Class name, usually in PascalCase; like camel case but with a capital letter. 
                3. Curly braces.
                4. Assign properties their values; use equal signs and semi-colons.

                Observe: 
                1. Create a class that defines built-in or default values.
                2. Create an object with built-in or default values.
                3. Put a debugger after the class and object.
                4. Directly display the class and object.
            </pre>

            <pre>
                Class v. object
                --------------------------
                <code>
                    class MyCar {
                        color = "red";
                        year = 2024;
                    }
                    
                    const myCar {
                        color = "red";
                        year = 2024;
                    }
                    
                    display(MyCar);
                    display(myCar);  
                </code>
                Directly displaying a class shows its code. 
                In developer tools, a class has a name and length.
                A JavaScript class is different than a JavaScript object.
                The syntax of a class is different than an object.

                <button onlick="classVObject()">Class v. Object</button>
            </pre>

            <pre>
                Create a new JS oject from a class
                ----------------------------------
                <code>
                    const myCar = new MyCar();
                    const myCar2 = new MyCar();
                    const myCar3 = new MyCar();
            
                    myCar2.color = "white";
                    myCar3.year = 2025;
                            
                function newObject() {
                const myCar = new MyCar();
                const myCar2 = new MyCar();
                const myCar3 = new MyCar();
                display(JSON.strigify (myCar));
                display(JSON.strigify (myCar2));
                display(JSON.strigify (myCar3));
                }
                </code>
                Constructs an object from a class. Creates a predefined object.

                What do you observe about constructing multiple objects from a class?
                    The objects start with the properties and values defined by the class.
                    The objects are independent. 
                    The values of their properties can be changed individually.

                1. Declare an object to store the value into.
                2. Add keyword <code>new</code>.
                3. Name of the class with parentheses and semi-colon.
                4. The value is an ojbect created from the class. 

                <button onclick="createObjectFromClass">New Object From Class</button>
            </pre>

            <pre>
                Promise
                -------
                <code>
                    const results = new Promise(myFunction);
                    const promise = new Promise(myFunction);

                    function makePromise() {
                        const promise = new Promise(myFunction);
                        display("Make a promise.")
                    }
                </code>

                A special class that runs a callback function.
                The object indicates the status of the callback function.
                A promise is not asynchronous. It immediately runs the callback function, myFunction.
                Status shows pending, even after myFunction has finished. The status must be manually changed.
                A promise is meant to be used by asynchronous code. The callback function must indicate when it has finished. 

                <button onclick="makePromise()">Make a Promise</button><br>
               
                Create a promise:
                1. Create myFunction that displays something.
                2. Create the function makePromise.
                3. Add a promise that runs myFunction.
                4. Display something after the promise.
                5. Activate makePromise with a button.
            <pre>
                Resolve function and resolve value
                ----------------------------------
                <code>
                    function myFunction(resolve) {
                    resolve();
                    }
                </code>

                The resolve function is a promise meant to be used by asynchronous code.
                The asynchronous code is supposed resolve to indicate when it's done.
                The value provided by a promise is known as a resolve function.
                Activating the resolve function changes the status to fulfilled. 
                The resolve function is a callback function. It is passed to the function that is given to the promise.
                It indicates that the Promise is fulfilled.

                <code>      
                    function resolveFunction(resolve) {
                        setTimeout(serverResponse, 5000);
                        display("Inside my myFunction.");
                    }
                    
                    function madePromise() {
                        const promise = new Promise(resolveFunction);
                        display("Made a promise.")
                    }
                    
                    function serverResponse() {
                       display("Your information has been processed successfully.");
                       resolve();
                    }
                </code>
                <button onclick="madePromise()">Make a Promise</button>

                The promise passes a value to my Function.
                1. Let <code>myFunction</code> accept a parameter.
                2. Display the value.

                The resolve function is meant to be used by asynchronous code.
                The resolve value gets passed to the callback of the then function.
                Promise shows pending while server is responding
                Error with the resolve function -- undefined.

                <code>
                       resolve(); becomes
                    resolve("The promise is fulfilled.");
                </code>
                The resolve value gets passed to the function.
                The promise supposedly gets fulfilled.
                A promise value is accessible.
            </pre>
            <pre>
                Scopes
                ------

                Global scope
                ------------
                Variables declared in the global scope are accessible throughout the page of code. Declare these variables outside the curly braces.
                Any code in the same file has access to the variable. 
                
                <code>
                    const PI = 3.14;
                    const globalVariable ="I'm in the global scope."
                </code>

                Function scope
                --------------.
                The declared variable is contained locally within the function and only accessible to that specific function.

                <code>
                    function myFunction {
                        const myVariable=5;
                    }
                </code>

                Block scope
                -----------
                Variables declared in the block scope are accessible only within that block of code {the block is enclosed within the curly braces}.

                <code>
                    while (false) {
                        const x = 5;
                    }

                    do {
                        const x=7;
                        document.write(x);
                    } while false;

                    if true {
                        const x - 8;
                    } else {
                        const x = 10;
                    }

                    {
                        let x = "x";
                        document.write(x);
                    }
                </code>
            </pre>
            <pre>
                Function in a function (nested feunction)
                ----------------
                <code>
                    function outerFunction () {
                        const message = "Hello world!";
                        innerFunction();

                        function innerFunction () {
                            display(message);
                        }
                    }
                </code>
                <button onclick="outerFunction()">Nested Function</button>

                    Functions can be defined in other functions. 
                    The inner function has access to variables in the outer function.
                    The inner function only runs when it is activated.
                <code>
                        function outerFunction () {
                        const message = "Message from the outer function.";
                        innerFunction();

                        function innerFunction() {
                        display (message);
                             }
                        }
                </code>
            </pre>
            <pre>
                Nested resolve function (promise)
                ----------------------------------
                <code>
                    function serverResolve(resolve) {
                        setTimeout(nestedServerRespons, 5000);
                        display("Inside my myFunction");
                                            
                            function nestedServerResponse() {
                            display("Form was successfully processed.");
                                resolve();
                            }
                        }
                </code>

                To give serverResponse access to resolve, put serverResponse inside the outer function.    
                AKA...Use an inner function to give access to the resolve function.

                What do you observe about serverResponse as an inner function?
                It has access to resolved.
                Promise is pending before the server response.
                Promise should resolve after the server response.
                No access to the promise after the server response .
                </pre>
                <button onclick="serverResolve()">Get Server Response</button>
            <pre>
                Then function
                -------------
                <code>
                    promise.then(getMessage);

                    function getMessage(resolveValue) {
                    display(resolveValue);
                    }
                </code>
                Use then to access the promise after the server response.
                The then function runs the callback function when the promise is resolved (fulfilled).
                The callback function has access to the resolve value.
                Create a then function:
                1. Create the function <code>getMessage</code>.
                2. Let <code>then</code> call <code>getMessage</code>.
                3. Add a parameter to <code>getMessage</code> and display it.
                4. Send a value to <code>resolve ();</code>.
            </pre>  
      
            <pre>
                Method
                ------
                <code>
                    promise.then (getMessage);
                    document.write("Hello world!");
                </code>
                A method is a function that's part of an object.
            </pre>
            <pre>
                Handler
                -------
                <code>
                    onsubmit="submitForm(event)"
                </code>
                A function that runs in response to an event. The event variable is used. 
                <code>Onlick</code>can also run a function in response to an event.
                Example events:
                1. a form is submitted
                2. a button is clicked
                A handler function usually starts with handle: handleSubmit or handleClick.
            </pre>

            <pre>
                Server response simulation
                --------------------------
                <code>
                    function serverResolve(resolve) {
                        setTimeout(nestedServerRespons, 5000);
                        display("Inside my myFunction");
                                            
                            function nestedServerResponse() {
                            display("Form was successfully processed.");
                                resolve();
                            }
                        }
                    
                    function getMessage(messageParameter) {
                        display(messageParameter);
                    }
                    
                    function serverResponsePromise {
                        const promise = new Promise(serverResolve);
                        promise.then(getMessage);
                        display("Made a promise.");
                    }
                </code>

            </pre>

        </main>
        <footer></footer>
       
    </body>
</htnl>